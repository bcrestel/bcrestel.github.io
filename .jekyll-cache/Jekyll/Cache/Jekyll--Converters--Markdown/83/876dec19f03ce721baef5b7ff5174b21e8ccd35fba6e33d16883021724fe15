I"Þ<p>The goal of this post is to dive deeper into the derivation of the backpropagation
algorithm. This entry can be seen as a sub-post of that main
<a href="/2018/11/13/deeplearnDIY">post</a>
discussing a Python implementation of an artificial neural network, and all
notations will be exactly the same. For conventions and definitions about
vector/matrix calculus, see that <a href="/2018/11/12/MatrixCalculus">post</a>.</p>

<p>The loss function is defined as the sum of individual contributions for each
data point $i$,</p>

\[\mathcal{L}(\{ {\bf W}^l, {\bf b}^l \}_l) = 
\frac1N \sum_{i=1}^N c(\{ {\bf W}^l, {\bf b}^l \}_l, {\bf x}_i, {\bf y}_i)\]

<p>For examples of loss functions, have a look at that
<a href="/2018/11/23/loss-fct">post</a>.
In this post, Iâ€™m going to focus only on how to calculate the derivatives 
\(\frac{\partial c({\bf x}_i)}{\partial {\bf b}^l}\)
and
\(\frac{\partial c({\bf x}_i)}{\partial {\bf W}^l}\).</p>

<h2 id="derivatives-with-respect-to-bf-bl">Derivatives with respect to ${\bf b}^l$</h2>

<p>Applying the chain-rule, we get that</p>

\[\frac{\partial c({\bf x}_i)}{\partial {\bf b}^l} = 
\frac{\partial {\bf a}^L}{\partial {\bf b}^l} \cdotp 
\frac{\partial c({\bf x}_i)}{\partial {\bf a}^L}\]

<p><strong>For the output layer</strong>, i.e., $l=L$, since ${\bf a}^L = {\bf W}^L \cdotp {\bf
a}^{L-1} + {\bf b}^L$, applying the chain-rule again
with $z^L_k$, we have</p>

\[\frac{\partial {\bf a}^L}{\partial b^L_j} = 
\sum_{k=1}^{n_L} \frac{\partial {\bf a}^L}{\partial z_k^L}
\frac{\partial z_k^L}{\partial b^L_j}\]

<p>Let ${\bf e}_k = [\dots,0,1,0,\dots]^T$ be the vector filled with all zeros
but for one 1 at the $k^\text{th}$ entry. Then, we have</p>

\[\frac{\partial {\bf a}^L}{\partial z_k^L} = f'(z_k^L) {\bf e}_k,
\quad \frac{\partial z_k^L}{\partial b^L_j} = \delta_{jk}\]

<p>This means</p>

\[\frac{\partial {\bf a}^L}{\partial b^L_j} = f'(z_j^L) {\bf e}_j\]

<p>Following the convention defined
<a href="/2018/11/12/MatrixCalculus">here</a>, weâ€™ll stack these vectors row by
row to get</p>

\[\frac{\partial {\bf a}^L({\bf x}_i)}{\partial {\bf b}^L} = 
\begin{bmatrix}
f'( z_1^L({\bf x}_i) )  &amp; &amp; 0 \\
  &amp;   \ddots &amp; \\
 0    &amp;  &amp;   f'(z_{n_L}^L({\bf x}_i))
\end{bmatrix}\]

<p>In the end, with \(z_k^L({\bf x}_i) = ({\bf w}^L_k)^T \cdotp {\bf a}^{L-1}({\bf
x}_i) + b^L_k\), we
get</p>

\[\frac{\partial c({\bf x}_i)}{\partial {\bf b}^L} = 
\begin{bmatrix}
f'( z_1^L({\bf x}_i) )  &amp; &amp; 0 \\
  &amp;   \ddots &amp; \\
 0    &amp;  &amp;   f'(z_{n_L}^L({\bf x}_i))
\end{bmatrix} \cdotp 
\frac{\partial c({\bf x}_i)}{\partial {\bf a}^L}\]

<p>Using the results in the post <a href="/2018/11/23/loss-fct">loss function</a>, we can show
actual examples. For a least-square loss function, we have
\(\frac{\partial c({\bf x}_i)}{\partial {\bf a}^L} = ({\bf a}^L({\bf x}_i) -
{\bf y}_i)\). Whereas in the case of a multi-class classifier with a softmax
output layer (which is not actually covered by the above formula), we would have
\(\frac{\partial c({\bf x}_i)}{\partial {\bf a}^L} = a^L({\bf x}_i)_{y_i} {\bf e}_{y_i}\).</p>

<p><strong>For an interior layer $l$</strong>, we need to write an induction between successive
layers. But first, letâ€™s make a few observations. In the derivatives, the
variables ${\bf z}^l$ and ${\bf b}^l$ are inter-changeable. Indeed, since
\(\frac{\partial {\bf z}^l}{\partial {\bf b}^l} = I_{n_l}\), we have</p>

\[\frac{\partial \cdotp}{\partial {\bf b}^l} = 
\frac{\partial {\bf z}^l}{\partial {\bf b}^l}
\frac{\partial \cdotp}{\partial {\bf z}^l} = \frac{\partial \cdotp}{\partial
{\bf z}^l}\]

<p>Next, the result for \(\frac{\partial {\bf a}^L}{\partial {\bf b}^L}\) 
derived above
can be generalized to any layer $l$, i.e.,</p>

\[\frac{\partial {\bf a}^l({\bf x}_i)}{\partial {\bf b}^l} = 
\begin{bmatrix}
f'( z_1^l({\bf x}_i) )  &amp; &amp; 0 \\
  &amp;   \ddots &amp; \\
 0    &amp;  &amp;   f'(z_{n_l}^l({\bf x}_i))
\end{bmatrix}\]

<p>We now apply the chain-rule,</p>

\[\begin{align*}
\frac{\partial c({\bf x}_i)}{\partial {\bf b}^l} &amp; = \frac{\partial c({\bf x}_i)}{\partial {\bf z}^l} \\
 &amp; = \frac{\partial {\bf a}^l}{\partial {\bf z}^l} 
 \frac{\partial {\bf z}^{l+1}}{\partial {\bf a}^l} 
\frac{\partial c({\bf x}_i)}{\partial {\bf z}^{l+1}} \\
 &amp; = \frac{\partial {\bf a}^l}{\partial {\bf b}^l} 
 \frac{\partial {\bf z}^{l+1}}{\partial {\bf a}^l} 
\frac{\partial c({\bf x}_i)}{\partial {\bf b}^{l+1}} 
\end{align*}\]

<p>And in the end,</p>

\[\frac{\partial c({\bf x}_i)}{\partial {\bf b}^l} =
\begin{bmatrix}
f'( z_1^l({\bf x}_i) )  &amp; &amp; 0 \\
  &amp;   \ddots &amp; \\
 0    &amp;  &amp;   f'(z_{n_l}^l({\bf x}_i))
\end{bmatrix} \cdotp
({\bf W}^{l+1})^T \cdotp
\frac{\partial c({\bf x}_i)}{\partial {\bf b}^{l+1}}\]

<h2 id="derivatives-with-respect-to-bf-wl">Derivatives with respect to ${\bf W}^l$</h2>

<p>I am going to re-use the results in the previous section. In fact, this is yet
another application of the chain-rule,</p>

\[\begin{align*}
\frac{\partial c({\bf x}_i)}{\partial {\bf w}_i^l} &amp; = 
 \frac{\partial {\bf z}^l}{\partial {\bf w}_i^l}  
 \frac{\partial c({\bf x}_i)}{\partial {\bf z}^l}  \\
&amp; = \begin{bmatrix}  \dots &amp; 0 &amp; {\bf {a}}^{l-1}({\bf x}_i) &amp; 0 &amp; \dots \end{bmatrix} \cdotp
 \frac{\partial c({\bf x}_i)}{\partial {\bf b}^l} \\
 &amp; = {\bf a}^{l-1}({\bf x}_i) \frac{\partial c({\bf x}_i)}{\partial b^l_i} 
\end{align*}\]

<p>Since \({\bf W}^l = [{\bf w}_1^l,\dots,{\bf w}_{n_l}^l]^T\), we stack all
\(\frac{\partial c({\bf x}_i)}{\partial {\bf w}_i^l}\) in columns then take the transpose
to get</p>

\[\frac{\partial c({\bf x}_i)}{\partial {\bf W}^l} =
\frac{\partial c({\bf x}_i)}{\partial {\bf b}^l} \cdotp ({\bf a}^{l-1}({\bf x}_i))^T\]

<h2 id="comments">Comments</h2>

<h4 id="dead-neurons">Dead neurons</h4>

<p>It is informative to investigate what can cause the gradient of the cost
functional to be zero. Note that this only applies to a single datapoint.</p>

<p>(1) that will be the case if the next layer is dead (all gradients evaluate to
zero), b/c of the back-propagation recursion. So once you have a dead layer (all
neurons in that layer are dead), then you stop backpropagating past that layer.</p>

<p>(2) that will also be the case if $fâ€™(z^l_i) = 0$. With RELU, this will happen
with negative values of ${\bf z}^l$, and for sigmoid / tanh, this will happen with very large
values (either negative of positive).</p>

<p>(3) if a column of ${\bf W}^{l+1}$ is zero.</p>

<h4 id="parallelism">Parallelism</h4>

<p>The backpropagation algorithm is inherently sequential, which makes its
parallelism challenging, besides the embarassing parallelism of the sum over the
data points. This is actually an advantage for batch algorithms, that require all
$N$ points, over stochastic algorithms like stochastic gradient which compute
the derivative for a single data point $i$.</p>

<h4 id="checkpointing">Checkpointing</h4>

<p>To compute the derivatives, you need to store all \({\bf
a}^l({\bf x}_i)\) that were computed during the forward propagation.
Iâ€™m wondering if memory storage could be an issue. In which case a checkpointing
algorithm would be a natural solution</p>

<h4 id="higher-order-derivatives">Higher-order derivatives</h4>

<p>The next step is to look at how you can compute the action of a given vector on
the Hessian of the loss function.</p>
:ET